# -*- coding: utf-8 -*-
"""ML-AM_Proposed_implementation_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qma0urOQwfneAFWwmY6bdUxdHONSIDry
"""

# Commented out IPython magic to ensure Python compatibility.
# %load_ext autoreload
# %autoreload 2

import pandas as pd
import numpy as np
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf

from google.colab import drive
drive.mount("/content/drive", force_remount=True)
import os
GOOGLE_DRIVE_PATH_AFTER_MYDRIVE = 'ML for AM (additive manufacturing)/proposedImplementation/new_data'
GOOGLE_DRIVE_PATH = os.path.join('drive', 'MyDrive', GOOGLE_DRIVE_PATH_AFTER_MYDRIVE)
print(os.listdir(GOOGLE_DRIVE_PATH))

# Commented out IPython magic to ensure Python compatibility.
plt.rcParams['figure.figsize'] = (10.0, 8.0)
plt.rcParams['image.interpolation'] = 'nearest'
plt.rcParams['image.cmap'] = 'gray'

# %matplotlib inline

def gradient(grad):
    grad['gradient'] = grad['height'].diff().fillna(0)
    return grad

train_dfs = []
test_dfs = []
for i in range(1, 8):
    train_data = pd.read_csv(f'/content/drive/MyDrive/ML for AM (additive manufacturing)/proposedImplementation/new_data/dataset{i}.csv')
    train_data = gradient(train_data)
    train_dfs.append(train_data)

for i in range(8, 16):
    test_data = pd.read_csv(f'/content/drive/MyDrive/ML for AM (additive manufacturing)/proposedImplementation/new_data/dataset{i}.csv')
    test_data = gradient(train_data)
    test_dfs.append(test_data)
train_data = pd.concat(train_dfs, ignore_index=True)
test_data = pd.concat(test_dfs, ignore_index=True)

X_train = train_data['gradient'].values.reshape(-1, 1)
y_train = train_data['pore'].values.reshape(-1, 1)
X_test = test_data['gradient'].values.reshape(-1, 1)
y_test = test_data['pore'].values.reshape(-1, 1)

#X_train = tf.convert_to_tensor(X_train_np, dtype=tf.float32)
#y_train = tf.convert_to_tensor(y_train_np, dtype=tf.float32)
#X_test = tf.convert_to_tensor(X_test_np, dtype=tf.float32)
#y_test = tf.convert_to_tensor(y_test_np, dtype=tf.float32)

from tensorflow.keras import backend as K
def focal_loss(y_true, y_pred, alpha=0.25, gamma=2):
    y_pred = K.clip(y_pred, K.epsilon(), 1 - K.epsilon())
    pt_1 = tf.where(tf.equal(y_true, 1), y_pred, tf.ones_like(y_pred))
    pt_0 = tf.where(tf.equal(y_true, 0), y_pred, tf.zeros_like(y_pred))
    return -K.mean(alpha * K.pow(1. - pt_1, gamma) * K.log(pt_1)) - K.mean((1 - alpha) * K.pow(pt_0, gamma) * K.log(1. - pt_0))

from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, accuracy_score, classification_report
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout


class_weights = {0: 1, 1: 30}

# Reshape input data for LSTM (samples, time steps, features)
X_train = X_train.reshape((X_train.shape[0], 1, X_train.shape[1]))
X_test = X_test.reshape((X_test.shape[0], 1, X_test.shape[1]))

# Define the LSTM model
model = Sequential([
    LSTM(64, input_shape=(X_train.shape[1], X_train.shape[2])),
    Dropout(0.2),
    Dense(32, activation='relu'),
    Dropout(0.2),
    Dense(1, activation='sigmoid')
])

# Compile the model
model.compile(optimizer='adam', loss=focal_loss, metrics=['accuracy'])

# Train the model
model.fit(X_train, y_train, epochs=50, batch_size=32, class_weight=class_weights, validation_split=0.2)

# Evaluate the model on the test set
loss, accuracy = model.evaluate(X_test, y_test)
print("Test Loss:", loss)
print("Test Accuracy:", accuracy)

# Make predictions on the test data
y_pred_proba = model.predict(X_test)
y_pred = np.round(y_pred_proba).astype(int)

matrix = confusion_matrix(y_test, y_pred)
disp = ConfusionMatrixDisplay(confusion_matrix=matrix, display_labels=['No pore formation', 'Pore formation'])
disp.plot(cmap='Blues')
plt.title(f'Pore Formation Prediction Results')
plt.show()

print(classification_report(y_test, y_pred))

c_idx = np.where((y_test == 1) & (y_test == y_pred))

correct_pores = X_test[c_idx]

print("Gradient values of correctly classified pores:")
print(correct_pores)

m_idx = np.where((y_test == 1) & (y_test != y_pred))

misclassified_pores = X_test[m_idx]

print("Gradient values of misclassified pores:")
print(misclassified_pores)